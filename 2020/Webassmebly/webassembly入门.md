# webassemlby入门课  

## 一 课前必读  

### 1 我们为什么了解Webassmebly  

定义：  WebAssembly 是基于栈式虚拟机的虚拟二进制指令集（V-ISA），它被设计为高级编程语言的可移植编译目标  

Wasm 的出现更能够让我们直接在 Web 平台上，使用那些业界已存在许久的众多优秀的 C/C++ 代码库  

2017 年 8 月，W3C WebAssembly Working Group 成立，意味着 WebAssembly 正式成为 W3C 众多技术标准中的一员。  
wasm介绍：
Wasm 的历史和起源；  
Wasm 采用的计算模型和体系结构；  
Wasm 模块的内部结构；  
Wasm 相关的实战和应用。  

### 2  基础篇：学习此课程你需要了解哪些基础知识？  
跳过  


### 3  历史篇：为什么会有 WebAssembly 这样一门技术？  

js是弱类型语言，也可以称为解释型语言，执行效率较低，尽管拥有jit优化，不过如果编写者不按照jit优化方式去编写代码，jit是不会生效的。所以导致js语言执行效率较低。  

在wasm之前有很多提高js性能的方案，其中包括NACI和PNACI，但是都由于架构设计和技术局限性导致落地难度大。  

除了 NaCl 与 PNaCl，另一个不可不提的技术便是 Mozilla 于 2013 提出的 ASM.js。同前两者一样，ASM.js 的设计目标也是为了能够在 JavaScript 语言之外，为“构建更高性能的 Web 应用”这个目标，提供另外一种实现的可能。  

asm.js  
- 1. 是js子集，可以视为普通js来执行，拥有良好的兼容性  
- 2. 通过注解的方式标记asm.js代码，当满足一定条件时，浏览器通过注解识别到是asm.js进而直接编译成机器码，当再次执行时直接执行编译好的机器码。  

demo 
```
function asm (stdin, foreign, heap) {
  // 注解
  "use asm";
  function add (x, y) {
    x = x|0; // 变量 x 存储了 int 类型值；
    y = y|0; // 变量 y 存储了 int 类型值；
    var addend = 1.0, sum = 0.0; // 变量 addend 和 sum 默认存放了"双精度浮点"类型值；
    sum = sum + x + y; return +sum; // 函数返回值为"双精度浮点"类型；
  }
  return { add: add };
}
```  

## 二 核心原理篇  

### 1. wasm是一门新语言吗？  

“WebAssembly（缩写为 Wasm）是一种基于堆栈式虚拟机的二进制指令集。Wasm 被设计成为一种编程语言的可移植编译目标，并且可以通过将其部署在 Web 平台上，以便为**客户端及服务端应用程序提供服务**”。这是 Wasm 官网给出的一段，对 “Wasm 是什么？” 这个问题的解答。


常见计算机**计算模型**：
- 1. 堆栈机模型（现在常用）：先进后出
- 2. 寄存器机模型
- 3. 累加器机模型

ISA和V-ISA  

通常来说，对于可以应用在诸如 i386、X86-64 等实际存在的物理系统架构上的指令集，我们一般称之为 ISA（Instruction Set Architecture，指令集架构）。而对另外一种使用在虚拟架构体系中的指令集，我们通常称之为 V-ISA，也就是 Virtual（虚拟）的 ISA。  

对这些 V-ISA 的设计，大多都是基于堆栈机模型进行的。而 Wasm 就是这样的一种 V-ISA。

Wasm 之所以会选择堆栈机模型来进行指令的设计，其主要原因是由于堆栈机本身的设计与实现较为简单。快速的原型实现可以为 Wasm 的未来发展预先试错。  

wasm指令集：

```
i32.const 1
i32.const 2
i32.add
```

另外要提到的是，类比汇编语言与机器码。这里我们看到的诸如 “i32.const” 与 “i32.add” ，其实都是 Wasm 这个 V-ISA 指令集中，各个指令所对应的文本助记符（mnemonic）。实际当这些助记符被编译到 Wasm 二进制模块中时，会使用助记符所对应的二进制字节码（一般被称为 OpCode，你可以简单地将其理解为一些二进制数字），并配合一些编码算法来压缩整个二进制模块文件的体积。  

**Wasm 被设计成为一种编程语言的可移植编译目标**: 这句话意思是他只是一个目标并不是让你去编写，而是有编译器来将c/c++直接编译成wasm



